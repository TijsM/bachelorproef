\chapter{Proof-of-concept}
\label{ch:Proof-of-concept}


In deze proof-of-concept zal er onderzocht worden als een PWA kan voldoen aan het verwachtingspatroon van een gebruiker op een native applicatie.

Er zal een applicatie ontwikkeld worden waarbij een aangemelde gebruiker een andere persoon zal kunnen uitnodigen om een video gesprek te hebben. 

 \section{Analyse}
	 \subsection{Functionele requirements}
	 	\subsubsection{Authenticatie}
		 	\begin{itemize}
			 	\item Als een gebruiker wil ik me kunnen registreren met externe platformen (facebook, google, ...) zodat ik minder wachtwoorden hoef te onthouden.
			 	\item Als een aangemelde gebruiker wil ik aangemeld blijven als ik de applicatie sluit zodat ik tijd bespaar door niet niet bij elk gebruik te moeten aanmelden.
		 	\end{itemize}
		 	
		 \subsubsection{Bellen}
			  \begin{itemize}
			   	\item Als een aangemelde gebruiker wil ik een 'room' aanmaken waar ik een video-gesprek kan starten zodat ik in contact kan blijven met iemand waar ik niet fysiek bij kan zijn.
			   	\item Als een aangemelde gebruiker wil ik eenvoudig een link kunnen kopiÃ«ren naar mijn room zodat ik deze kan delen met iemand.
			   	\item Als een aangemelde gebruiker wil ik mijn 'rooms' kunnen beheren.
			   	\item Als een aangemelde gebruiker wil ik een notificatie ontvangen als iemand in mijn 'room' komt.
			  \end{itemize}
	 	
	 	\subsubsection{Gebeld worden}
	 	 \begin{itemize}
				\item Als een gebruiker wil ik, als ik een link van een room ontvang, eenvoudig deelnemen aan een videogesprek.
	 	 \end{itemize}
	
		\subsubsection{Algemeen}
	 		\begin{itemize}
	 			\item Als een gebruiker wil een de toepassing toevoegen aan het startscherm van mijn toestel zodat ik deze snel kan openen.
	 			\item Als een aangemelde gebruiker wil ik de applicatie kunnen openen zonder internetverbinding zodat ik mijn overal en altijd mijn rooms kan bekijken.
			\end{itemize}
	 
	\subsection{Niet-functionele requirements}
		\begin{itemize}
			\item Als een gebruiker wil ik een video-gesprek kunnen hebben met een zo laag mogelijke vertraging zodat ik geen problemen heb met communiceren.
			\item Als een gebruiker wil ik video-gesprekken voeren op een veilige manier zodat niemand informatie kan achterhalen die ik niet publiek wou maken.
		\end{itemize} 
		


\section{Design}
		\subsection{Mockup}
					
			Voor er een design gemaakt werd, werden er mockups opgesteld.
			Aan de hand van deze mockups met weinig detail, kon er snel gestart worden met het ontwikkelen van de functionaliteiten. \autocite{Tate2019}
			\begin{figure}[H]
				\centering
				\includegraphics[width=140mm]{./img/mockup-poc.png}{}
				\caption{mockups in figma}
			\end{figure}
		
		
		\subsection{Prototype}
		
			Vervolgens werd er een klikbaar prototype gemaakt. In de dit prototype werd de stijl van de applicatie bepaald.
			
			Er werd gekozen om een eenvoudig design te implementeren met illustraties die van \href{https://undraw.co/}{unDraw} verkregen werden.
			
			\begin{figure}[H]
				\centering
				\includegraphics[width=140mm]{./img/prototype-poc.png}{}
				\caption{prototype in figma}
			\end{figure}
			
	
\section{Implementatie}
	Voor het ontwikkelen van de proof-of-concept werd er opnieuw react.js gebruikt voor de frontend. De backend werd ontwikkeld in node.js en als database werd de firestore van firebase gebruikt.
	
	De code van dit project kan op github gevonden worden: https://github.com/TijsM/videocall-pwa
	
	\subsection{Registreren service worker}
		
		In Hoofdstuk~\ref{ch:TransformerenNaarEenPWA} werd vermeld dat een standaard react applicatie al een service worker heeft die voor caching van statische bestanden zorgt. Deze service worker wordt gegenereerd tijdens het build proces door de library \href{https://github.com/goldhand/sw-precache-webpack-plugin}{sw-precache-webpack-plugin. }  
		\autocite{Mester2019}
		
		Door een service worker te genereren zorgt react ervoor dat het heel eenvoudig is om statische bestanden te cachen en een website offline beschikbaar te maken.
		
		Deze strategie heeft echter Ã©Ã©n groot nadeel, de service worker die react genereert kan niet worden aangepast door de ontwikkelaar. Als de applicatie een meer geavanceerde service worker nodig heeft, zal deze automatisch gegenereerde service worker moeten overschreven worden.
		
		Het artikel van Chinmaya Pati dat gepubliceerd werd op Medium beschrijft dit proces. \autocite{Pati2019}
		
	\subsection{A2HS}
	
		De applicatie voldoet aan alle criteria om geÃ¯nstalleerd te kunnen worden op toestellen. Echter zal de gebruiker geen standaard melding te zien krijgen om de applicatie te installeren.		
		
		Als de applicatie de gebruiker vraagt om de de applicatie toe te voegen aan het startscherm en de gebruiker staat dit niet toe, zal het beforeInstallPrompt nooit meer opnieuw opgeroepen worden. Deze melding kan dus maar 1 maal getoond worden.
		
		Om de kans te verhogen dat de gebruiker de applicatie toevoegt aan het startscherm zal deze melding enkel getoond worden als de gebruiker daar expliciet naar vraagt.
		\autocite{Mclachlan2020}
		
		Als de applicatie opstart zal het beforeInstallPrompt opgevangen worden en opgeslagen worden in de state. Door het standaard gedrag te overschrijven zal de melding nog niet getoond worden aan de gebruiker.
		\autocite{LePage2020b}
		
\begin{lstlisting}
window.addEventListener("beforeinstallprompt", (event) => {
	event.preventDefault();
	setPrompt(event);
}); 
\end{lstlisting}

		Vervolgens kan, als de gebruiker dit wenst, de melding toch getoond worden.
		
\begin{lstlisting}
const addToHome = () => {
	prompt.prompt();
};
\end{lstlisting}
	\subsection{Caching}
	
		\subsubsection{Cache strategieÃ«n}
		
			\subparagraph{Cache first}
				Er zal eerst naar het cache geheugen gekeken worden, als het gevraagde bestand hier niet aanwezig is zal er een netwerk verzoek verstuurd worden.
				
				Dit is ee populaire strategie als de data weinig veranderd. 
			\subparagraph{Network first}
				Er zal eerst een netwerk verzoek verstuurd worden, als deze niet succesvol was zal er gekeken worden als het bestand in het cache geheugen aanwezig is. 
				
				Dit is een populaire strategie als de data vaak veranderd.
			\subparagraph{Network only}
				Deze strategie wordt toegepast als er geen caching opgezet wordt. 
			\subparagraph{Cache only}
				Deze strategie zal nooit een netwerkverzoek versturen. Er kan enkel data opgehaald worden via het cache geheugen.
				
				Dit cache geheugen moet door de applicatie gevuld worden.
			\subparagraph{Stale-While-Revalidate}
				De staleWhileRevalidate strategie houdt in dat eerst het gecachete bestand gebruikt wordt, vervolgens wordt er een netwerkverzoek verstuurd. Als het lokale bestand en het bestand van de server niet volledig gelijk zijn, zal het gecachte bestand overschreven worden. En zal de content op in de applicatie aangepast worden.
				
				Dit is de meest populaire strategie omdat de pagina snel geladen wordt, en de inhoudt is up to date.

		\subsubsection{Statisch cachen}
			Statisch cachen is het cachen van bestanden die nodig zijn voor het opbouwen van de webapplicatie. Voorbeelden hiervan zijn foto's, style sheets, javascript bestanden, html bestanden, ...
			
			Op deze manier zal ook de application shell offline beschikbaar zijn.
			
			Door deze bestanden te cachen wordt de applicatie offline beschikbaar.
			
			In deze applicatie werd dit bereikt door \href{https://developers.google.com/web/tools/workbox}{workbox} te gebruiken.
			
			In een eerste fase wordt het index.html bestand gecached.
\begin{lstlisting}
workbox.precaching.precacheAndRoute([
  {url: '/index.html', revision: '1'},
]);
\end{lstlisting}
		
			Workbox zal de functie 'precacheAndRoute' uitvoeren als de service worker geÃ¯nstalleerd wordt. De bestanden die worden meegegeven in de array zullen vanaf dat moment offline beschikbaar zijn.
			\autocite{Workbox2020a}
			
			Bestanden die hier toegoevoegd worden zullen geleverd worden aan de hand van de 'cache first' strategie. Dit wil zeggen dat dit bestand enkel aan de server gevraagd zal worden als het niet beschikbaar is in het cache geheugen.
			
			Een andere manier waarop statische caching kan gedaan worden is aan de van de 'registerRoute' die Workbox aanbiedt. 
			
\begin{lstlisting}
workbox.routing.registerRoute(
  /\.(?:js|css)$/,
  workbox.strategies.staleWhileRevalidate({
    cacheName: "static-resources",
    plugins: [
      new workbox.expiration.Plugin({
        maxEntries: 60,
        maxAgeSeconds: 20 * 24 * 60 * 60, // 20 Days
      }),
    ],
  })
);
\end{lstlisting}
			
			Aan de hand van een regular expression kunnen er bestanden gechachet worden. In dit voorbeeld worden alle javascript en css bestanden offline beschikbaar gemaakt.
			
			In dit voorbeeld wordt de Stale-While-Revalidate strategie toegepast.
			\autocite{Workbox2020b}
			
		\subsubsection{dynamisch cachen}
			Dynamisch cachen houdt in dat data die de gebruiker vraagt ook offline opgeslagen wordt. Dit zullen vaak requests van REST-API's zijn.
			
			In deze applicatie werd dynamisch cachen toegepast om de laatste versie van de rooms nog steeds te tonen aan de gebruiker, ookal als deze offline.
			
\begin{lstlisting}
workbox.routing.registerRoute(
  /.*(?:googleapis|)\.com.*$/,
  workbox.strategies.staleWhileRevalidate({
    cacheName: "firebase",
  })
);
\end{lstlisting}
		
		Opnieuw wordt er gebruik gemaakt van een regular expression om workbox duidelijk te maken welke request er offline beschikbaar moet zijn.

	\subsection{Authenticatie}
		
		Het invullen van van een form om een mobiel toestel is voor veel gebruikers een relatief grote inspanning.
		
		In het artikel van Nick Babich wordt de term "interaction cost" gebruikt. De interaction cost is de som van alle cognitieve en fysieke inspanningen die een gebruiker moet leveren om tot zijn doel te komen. Hoe lager de interaction cost hoe beter.
		\autocite{Babich2018}
		
		Het invullen van formulieren met data heeft een hoge interaction cost. Er moet veel getypt worden (fysieke inspanning). De gebruiker moet hierbij aandachtig zijn om zeker te zijn dat hij geen fouten maakt (cognitieve inspanning). het is dus belangrijk om de gebruiker hiervan te besparen.
		
		Dit kan gedaan worden door de gebruiker te laten registreren via een ander platform, hierbij moet er vaak helemaal niet, of veel minder getypt worden.
		
		Op deze applicatie kan de gebruiker zich aanmelden met Google en Facebook.
		
		Dit werd bereikt door gebruikt te maken van "Firebase authentication".
		
		
\begin{lstlisting}
export const auth = firebase.auth();
const provider = new firebase.auth.GoogleAuthProvider();

export const authWithGoogle = () => {
	return auth.signInWithPopup(provider)
};
\end{lstlisting}
	
		Deze code geeft alle relevante informatie terug die google over de gebruiker heeft. Dit bevat volgende eigenschappen:
		\begin{itemize}
			\item Voornaam
			\item Familienaam
			\item Volledige naam
			\item Email
			\item Profielfoto
			\item Voorkeurstaal
			\item ...
		\end{itemize} 
		
		Gelijkaardige code kan geschreven worden voor het aanmelden met andere platformen zoals:
		\begin{itemize}
			\item Twitter
			\item Github
			\item Apple
			\item Microsoft
			\item ...
		\end{itemize} 
		
	\subsection{Share API en Clipboard API}
	
		In de applicatie is het belangrijk om op een intuÃ¯tieve manier een link te kunnen delen naar een room. 
		Dit werd bekomen door de Share API te gebruiken.
		Op mobiele toestellen zal deze een native menu openen waar de gebruiker de link kan delen via verschillende platformen.
		
		Echter bieden enkel chrome voor android en safari dit aan. Er kan er dus niet vanuit gegaan worden dat de gebruiker dit kan implementeren.

\begin{lstlisting}
 const shareData = {
      title: 'Join my room!',
      text: 'Click on the link and we can have a video chat ;-)',
      url: `https://videocall-pwa.netlify.app/visitroom/${owner}/${room}`,
    }
    navigator.share(shareData)
\end{lstlisting}

		\begin{figure}[H]
			\centering
			\includegraphics[width=35mm]{./img/share-ios}{}
			\caption{native share-menu op IOS}
		\end{figure}	
		\begin{figure}[H]
			\centering
			\includegraphics[width=35mm]{./img/share-android.jpg}{}
			\caption{native share-menu op Android}
		\end{figure}

		Als de gebruiker een browser gebruikt die deze functie niet ondersteunt, zal de clipboard API gebruikt worden.
	
		De clipboard API kan gebruikt worden om items in het klembord van de gebruiker te plaatsen of om het klembord uit te lezen.
		
		Deze web-API werd gebruikt om eenvoudig de link van de room te kunnen delen met een persoon die gecontacteerd zal worden.
		
		Volgende code zal de link genereren die de uitgenodigde persoon kan gebruiken en zal deze in het klembord van de gebruiker plaatsen.
		
		De eerste keer dat dit proces uitgevoerd wordt zal de gebruiker expliciet toestemming moeten geven om het klembord te mogen gebruiken.

\begin{lstlisting}
navigator.clipboard
  .writeText(`http://localhost:3000/visitroom/${roomownername}/${roomname}`)
  .then(() => {
    alert("coppied!! share the coppied link with somebody");
  });
};
\end{lstlisting}

		\subsubsection{Progressive enhancement}

			Bij deze feature werd er progressive enhancement toegepast. 
			In het beste geval wordt het native deel-menu getoond, als dit niet beschikbaar is zal de link gekopiÃ«erd worden in het klembord.
			Als ook dit niet beschikbaar is, of de gebruiker heeft geen toestemming gegeven zal er een boodschap getoond worden waar de gebruiker de link zelf kan kopiÃ«ren en delen.
		
\begin{lstlisting}
if('share' in navigator){jesu
	// ... code voor het delen via een native menu ...
}
else{
	//... code voor het kopiÃ«ren van de link ...
	.catch(() => {
		//tonen van een boodscahp met de link die gedeeld moet worden
		swal(`you can share this link:
			https://videocall-pwa.netlify.app/visitroom/${owner}/${room}
		`);
	});
}
\end{lstlisting}


	\subsection{Push notificaties}
	
		Een van de grote voordelen van een PWA ten opzichte van een traditionele website is dat het push notificaties kan sturen naar de gebruiker.
		
		Er wordt aangeraden om de "web-push" library te gebruiken om push notificaties te implementeren
		
		In deze applicatie worden push notificaties gebruik in twee use-cases. 
		\begin{itemize}
			\item 	Als een bezoeker in een room komt, zal de eigenaar van die room een meding krijgen
			\item 	De administrator van de applicatie kan een notificatie naar alle gebruikers versturen aan de hand vanuit een admin scherm
		\end{itemize}	
		
		\paragraph{Abbonneren op push notificaties}
			 De gebruiker moet expliciet toegang geven aan de webapplicatie om push notificaties te mogen gebruiken.
			 
\begin{lstlisting}
const sw = await navigator.serviceWorker.ready;
let pushSub = await sw.pushManager.subscribe({
      userVisibleOnly: true,
      applicationServerKey: 'public VAPID key'
})
\end{lstlisting}

			Dit stukje code zal een subscription teruggeven dat opgeslagen moet worden in de databank bij de gebruiker. deze subscription is uniek voor de gebruiker, de browser en het toestel.
			\autocite{Gaunt2019a}
			
			voorbeeld van een subscription:
	
\begin{lstlisting}
{
   "endpoint":"https://fcm.googleapis.com/fcm/send/fOkirMCCHhM:..."
   "expirationTime":null,
   "keys":{
      "p256dh":"BBwYLrPvd2IIAo4cWsJhXRD2g9aFyL1Q3K9cuWh_...",
      "auth":"0orvSHRZrMb3zP0yIpUAcg"
   }
}
\end{lstlisting}


		\paragraph{Backend}
			De backend moet in een eerste fase gebruikt worden om de VAPID keys te genereren.
			
			Vapid keys of application server keys zijn uniek voor de server.
			
			Deze vapid keys zorgen ervoor dat de push services van de verschillende browsers weet van welke applicatie de notificaties afkomstig zijn. Hierdoor kan het ook de applicatie beveiligen en enkel deze server toestaan notificaties te sturen naar de applicatie.
			
			Elke browser heeft zijn eigen push service waar een applicatie server aan kan vragen om een notificiatie te sturen naar een bepaald toestel.
			\autocite{Gaunt2020}
			
			Deze vapid keys kunnen in de applicatie server gegenereerd worden aan de hand van volgende code:
			
\begin{lstlisting}
console.log(push.generateVAPIDKeys)
\end{lstlisting}

			Dit zal een publieke en een private sleutel weergeven in de console. Deze moeten dan op een veilige plaats opgeslagen worden.
			
			Eens de server de Vapid keys heeft kan deze een notificatie verzenden.
			
\begin{lstlisting}
push.setVapidDetails(
    "mailto:mai",
    secrets.vapIdKeys.publicKey,
    secrets.vapIdKeys.privateKey
  );
  
 push.sendNotification( sub,  JSON.stringify({payload})
\end{lstlisting}

			Er moet ook een geldig email adres opgegeven worden. Dit email adres zal gebruikt worden door de push service als er problemen zijn met jouw applicatie.
			
			De push notificatie kan dan verzonden worden met eventueel extra informatie in de payload.
			
		\paragraph{Service worker}
		
			Op basis van de subscription die in de backend werd verzonden zal de service worker van de juiste gebruiker geactiveerd worden.
			
			De service worker zal aan de hand van een 'eventListener' geactiveerd worden en een notificatie tonen op het toestel.
			
			
\begin{lstlisting}
self.addEventListener("push", function (e) {
	//handle notification
}
\end{lstlisting}
			
			Als de backend extra informatie heeft meegegeven kan deze uitgelezen worden.
\begin{lstlisting}
  const payload = JSON.parse(e.data.text())
\end{lstlisting}
			
			Vervolgens kan er een notificatie gevormd worden zoals eerder toegelicht in hoofdstuk 2 van deze scriptie.
			
\begin{lstlisting}
options = {
      body: "Open the app and say hi!",
      icon: "images/example.png",
      vibrate: [300, 50, 100],
      data: {
        dateOfArrival: Date.now(),
        primaryKey: "2",
      },
    };

    e.waitUntil( self.registration.showNotification(`notification title`, options)
\end{lstlisting}

	\begin{figure}[H]
		\centering
				\includegraphics[width=80mm]{./img/notificationMacOs}{}		
		\caption{notificatie op macOS}
	\end{figure}
			
	\subsection{Local storage}
		
		Om een ervaring aan te bieden zoals op native applicaties is het belangrijk om de gebruiker aangemeld te houden tussen sessies.
		
		Als een gebruiker zich aanmeldt, wordt deze opgeslagen in het local storage.
		
		Zolang de gebruiker het local storage niet manueel verwijdert zal dit blijven bestaan. 
		\autocite{Mozilla2020d}
		
	\subsection{Web RTC}
		
		Web RTC is een verzameling van Web API's die real time commicatie op het web mogelijk maken. 
		
		In deze applicatie werd Web RTC gebruikt om:
		\begin{itemize}
			\item de camera van het toestel te gebruiken en een video-stream op het scherm te tonen.
			\item een peer-to-peer connectie op te zetten tussen twee gebruikers
			\item video tussen beide gebuikers te streamen
		\end{itemize} 
		\autocite{webRTC2020}
		
		Web RTC maakt gebruik van een peer-to-peer connectie tussen de twee gebruikers, tijdens het bellen is er dus geen server nodig. Echter, er is wel een server nodig om de connectie tussen beide tot stand te brengen.
		
		\paragraph{video-stream}
			De video-stream zal verkregen worden via het navigator object. Bij het opvragen van een video-stream zal de browser automatisch toestemming vragen aan de gebruiker als de camera en de microfoon gebruikt mogen worden.
			
			Als de applicatie toestemming gekregen heeft wordt er een video-stream verkregen.
			Deze stream zal opgeslagen worden in de state van de applicatie en zal in een HTML-5 video element geplaatst worden.
		
\begin{lstlisting}
navigator.mediaDevices.getUserMedia({ 
		video: true,
		audio: true 
	}).then((stream) => {
		setYourVideoStream(stream);
		if (yourVideo.current) {
			yourVideo.current.srcObject = stream;
		}
	});
\end{lstlisting}


		\paragraph{peer-to-peer verbinding met streaming}
			Bij deze applicatie werd \href{https://github.com/feross/simple-peer}{simple-peer} gebruikt, dit is een abstractie van webRTC die het opzetten van peer-to-peer verbindingen eenvoudiger maakt.
			
			Voor beide gebruikers zal er een peer object aangemaakt worden.

\begin{lstlisting}
const peer = new Peer({
	initiator: true,

	stream: yourVideoStream,
});
\end{lstlisting}
			
			vervolgens zullen er listeners toegevoegd worden aan deze objecten die geactiveerd zullen worden op basis van het andere peer object
			
\begin{lstlisting}
peer.on("signal", (data) => {
	// code wordt uitgevoerd als er een andere peer aangemaakt wordt
});

peer.on("stream", (stream) => {
	// code wordt uitgevoerd als de andere peer start met het streamen van een video
});
\end{lstlisting}

		\paragraph{Performantie}
		
			De performantie van de applicatie werd gemeten aan door het de statistieken van de video elementen op te halen waarint de stream getoond wordt. Bij beide tests was een macbook Pro de administrator van de meeting en werd een Oneplus6 toegevoegd aan het gesprek als gast. De statistieken werden gemeten op het toestel van de administrator.
			
			\begin{table}[H]
			\centering
			\begin{tabular}{lll}													& Zoom 			& PWA \\
				gemiddelded aantal frames per seconde van ontvangende video 	 & 14				&  34 \\
				gemiddelded aantal frames per seconde van verzonden video		   & 26				   & 30	 \\
				resolutie ontvangen video  						  & 480x640 	&  480x640  \\
				resolutiie verzonden video						   & 640x360	& 	640x480\\
			\end{tabular}	
			\caption{performantie vergelijking met Zoom}
			\end{table}
	

	\subsection{Socket.io}
	
		Zoals eerder vermeld is er een server nodig om een peer-to-peer connectie tot stand te brengen.
		
		Deze backend werd geschreven in node.js en werd gehost op \href{https://glitch.com/}{glitch}.
		
		De library \href{https://socket.io/}{socket.io} werd gebruikt websocktets te implementeren. Websockets zorgen ervoor dat een server met de frontend kan cummuniceren zonder dat deze er expliciet om vragen. 
		
		In traditionele applicaties krijgt de frontend enkel data als hij hier een request voor stuurt naar de backend, bij websockets kan de backend de frontend met data voorzien in real time.
		\autocite{Mozilla2020e}
		
		Deze real-time communicatie is nodig voor het opzetten van een peer-to-peer connectie.
		
		De backend zal de frontend informeren als er een gebruiker in een room komt, vervolgens kan er een peer-to-peer connectie opgezet worden.
		
		Zowel de frontend als de backend kunnen een event sturen en naar events luisteren. Op deze manier wordt er gecomuniceerd. 	
		
			
	\subsection{Masked icons}
	
		Het startscherm van android toestellen kan in veel verschillende vormen komen. De producent van een android toestel kan zelf een thema ontwikkelen voor het startscherm.
		
		In verschillende thema's zullen de icoontjes er anders uitzien, in sommige thema's zullen ze rond zijn, in andere vierkant met afgeronde hoeken. 
		
		Als het icoontje niet geoptimaliseerd wordt, zal Android er steeds voor zorgen dat het icoontje volledig zichtbaar is. Indien nodig zal er een achtergrond toegevoegd worden.
		
		Door ervoor te zorgen dat alle belangrijke elementen va het icoon binnen een 'safe zone' vallen, en een extra property toe te voegen in het app manifest kan dit opgelost worden.
		
\begin{lstlisting}
"purpose": "any maskable" 
\end{lstlisting}

		\begin{figure}[H]
			\centering
			\includegraphics[width=60mm]{./img/traditionalIcons}{}
			\caption{niet geoptimaliseerde iconen}
		\end{figure}
		\begin{figure}[H]
			\centering
			\includegraphics[width=60mm]{./img/maskedicons}{}
			\caption{masked iconen}
		\end{figure}
		\begin{figure}[H]
			\centering
			\includegraphics[width=100mm]{./img/iconPWA.png}{}
			\caption{Geoptimaliseerde iconen van proof-of-concept}
		\end{figure}


\section{De Applicatie}
	\subsection{Authenticatie}
		De gebruiker kan zich registreren aan de hand van een email en wachtwoord combinatie. Er is ook een optie om zicht aan te melden aan de hand van Google en Facebook.
		
		
		\begin{figure}[H]
			\centering
			\includegraphics[width=35mm]{./img/POC/login.jpg}{}		\includegraphics[width=35mm]{./img/POC/register.jpg}{}
			\caption{autenticatie-schermen}
		\end{figure}
		
	\subsection{Home}
		Dit is het scherm waar de gebruiker zal terechtkomen als hij is aangemeld. 
		Op dit scherm kan de gebruiker zijn rooms beheren, hij kan nieuwe rooms aanmaken, rooms verwijderen en rooms delen.
		
		Onderaan de pagina is er een horizontale scroll, in deze lijst kan de gebruiker volgende opties:
		\begin{itemize}
			\item De applictie installeren en toevoegen aan het startscherm
			\item Notificaties aan zetten 
			\item Afmelden
		\end{itemize}
		
			\begin{figure}[H]
				\centering
				\includegraphics[width=35mm]{./img/POC/home}{}		
				\caption{homescherm}
			\end{figure}
		
		
		
	\subsection{Wachtschermen}
		Als er slechts 1 persoon is in de room zal de gebruiker op dit scherm terechtkomen. 
		
		De eigenaar van de room heeft een optie om de room te delen. 
		
		Als een bezoeker in de room komt, zal de eigenaar een melding krijgen dat er iemand in zijn room is. Door op de notificatie te klikken gaat de eigenaar direct naar de room.
						
		Als beide gebruikers aanwezig zijn, zal de bezoeker de optie krijgen om het gesprek te starten.
		
		\begin{figure}[H]
			\centering
			\includegraphics[width=35mm]{./img/POC/waitAsOwner.jpg}{}		\includegraphics[width=35mm]{./img/POC/waitAsVisitor1.jpg}{}
			\includegraphics[width=35mm]{./img/POC/waitAsVisitor2.jpg}{}
			\caption{wachtschermen}
		\end{figure}
		
		
		
	\subsection{Room}
		In dit scherm kunnen de gebruikers een conversatie hebben. 
		
		Er is een optie om het gesprek te beÃ«indigen, het geluid uit te schakelen en de video stream uit te schakelen.
		\begin{figure}[H]
			\centering
			\includegraphics[width=35mm]{./img/POC/call.jpg}{}		
			\caption{belscherm}
		\end{figure}
		
	\subsection{Notificaties}
		Op dit scherm kan de administrator van de applicatie een zelf gekozen notificatie versturen naar alle gebruikers die hun goedkeuring hebben gegeven om notificaties te ontvangen.
		
		\begin{figure}[H]
			\centering
			\includegraphics[width=100mm]{./img/POC/sendNoti}{}		
			\caption{scherm om manueel een notificatie te versturen}
		\end{figure}
		

\section{Conclusie}



%todo: Toch vergelijken tussen PWA en native obv de functionaliteiten. bvb look en feel, maar natuurlijk ook de functionaliteiten die je hebt ingebouwd zoals 1malig aanmelden, notificaties,...
%todo: Bieden de web api's een gelijkwaardig alternatief voor  de native variant?
%todo: Kan voor de look en feel dan gebruik gemaakt worden van Ionic
%todo: OV's overlopen in de conclusie
	
	Al de vooropgestelde requirements kunnen bereikt worden door een PWA te implementeren. 
	Native features zoals camera, microfoon, delen, notificatie zijn relatief eenvoudig te implementeren in een webapplicatie.
	
	\subsection{Compatibiliteit en besturingssystemen}
		Zoals eerder aangehaald is een van de nadelen van PWA's de sterk variÃ«rende ondersteuning. Voor deze reden is het belangrijk dat de applicatie ontwikkeld wordt aan de hand van progressive enhancement. 
		
		De hoofdfunctionaliteit van de applicatie moet beschikbaar zijn voor alle gebruikers. Vervolgens kan de applicatie uitgebreid worden met functionaliteiten die de ervaring verbeteren maar die niet noodzakelijk zijn.
		
		In deze applicatie is de hoofdfunctionaliteit het videobellen. Zoals aangetoond in sectie ~\ref{ch: BesturingssystemenEnPWAs} wordt webRTC ondersteund op alle veelgebruikte browsers en toestellen.  Er werden vervolgens extra functionaliteiten toegevoegd zoals het delen van de link via het native deel-menu, de clipboard API, push notificaties en het automatisch toevoegen aan het startscherm.
		\begin{itemize}
	  		\item Het deel-menu is enkel beschikbaar op mobiele toestellen en safari op macOS.
	  		\item De clipboard API is beschikbaar op alle browsers en toestellen maar heeft wel de toestemming van de gebruiker nodig.
	  		\item Push notificaties zijn beschikbaar op alle browsers en toestellen met uitzondering van:
	  				\begin{itemize}
	  			  		\item alle browsers op IOS
	  			  		\item safari op macOS
	  		 		\end{itemize}	
  			\item automatisch toevoegen aan het startscherm is beschikbaar op alle browsers en toestellen met uitzondering van:
	  				\begin{itemize}
	  			  		\item alle browsers op IOS
	  			  		\item safari op macOS
	  		 		\end{itemize}	
 		\end{itemize}
 		
 	
 	\subsection{Beperkingen van een PWA}
 			
			Het is niet eenvoudig om consistent een goeie ervaring te bieden met Ã©Ã©n codebase voor alle platformen die ondersteund worden. 
			
			Er werd beslist om de maximale hoogte van de applicatie vast te zetten op 100vh,  op deze manier is het in principe onmogelijk om een scroll van de volledige pagina te hebben. 
			
			dit werkte goed op een desktop browser maar gaf problemen op mobiele toestellen.
			
			Op Android bijvoorbeeld maakt de adresbalk geen deel uit van de viewport. Hierdoor was er dus wel een scroll van enkele centimeters aanwezig als de applicatie bezocht werd in de browser. Dit probleem wordt opgelost als de applicatie geÃ¯nstalleerd wordt, dan is er geen adresbalk aanwezig.
			
	\subsection{Verwachting gebruiker}
		Een gebruiker die een applicatie installeert op een IOS toestel zal een andere user interface verwachten dan een gebruiker die een applicatie installeert op een Android toestel.
		
		Met een PWA kan er slechts 1 user interface geÃ¯mplementeerd worden, het is dus niet mogelijk om volledig aan de verwachting van elke gebruiker te voldoen.
		
		Een gebruiker met een toestel dat op IOS werkt is gewoon om naar de vorige pagina te navigeren door naar rechts te swipen op het toestel. Dit is een manier van navigeren die een Android gebruiker niet gewoon is. In deze proof of concept kan er niet met touch-gebaren genavigeerd worden. Dit kan niet 'native' aanvoelen voor de IOS gebruiker. 
		
		%todo:ðŸ“ˆ

		Uit de resultaten van de user testen bleek dat veel mensen niet weten welke functionaliteit beschikbaar is voor het web. Zo wist X\% niet dat een webapplicatie gebruik kan maken van de camera en X\% wist niet dat een website ook offline kan werken.
		
		Dit is relevant omdat als een gebruiker niet weet dat een PWA dit kan doen, dit waarschijnlijk ook niet zal testen. 
		%todo: âœ…resultaten van user testing - wat weet een gebruiker van het web
		
	\subsection{Gebruik van PWA's}
		%todo:âœ… resultaat van user testing - zou de gebruiker PWA verkiezen boven native
		In de user testen werd er gevraagd als een gebruiker een PWA zou verkiezen boven een native applicatie. 
		De meeste mensen zouden een native applicatie nog steeds verkiezen boven een PWA. De reden hiervoor is dat veel mensen enkel op zoek zijn naar een app enkel in de app stores zoeken. 
		
		%todo:âœ… resultaat van user testing - zou de gebruiker PWA verkiezen boven native MET CONTEXT WAT PWA IS
		%todo: --------getallen invullen ipv X
		In het onderzoek werd vervolgens dezelfde vraag opnieuw gesteld, maar nu werd er meer info gegeven aan de testpersoon over wat PWA's zijn. De tester werd verteld dat een PWA ook het startscherm kan staan, notificaties kan versturen, en dat de app-grootte veel kleiner is dan die van een native app. 
		%todo:ðŸ“ˆ
		Er was slechts X\% van de gebruikers die een PWA zou verkiezen boven de native versie.
		
		De testers hadden uiteenlopende redenen waarom ze een native applicatie verkozen:
		\begin{itemize}
	  		\item 'Heb geen reden om geen native gebruiken'
	  		\item 'Native heeft een beter gevoel'
	  		\item 'Ik vertrouw een webapplicatie minder dan een native applicatie'
	  		\item 'Heb geen reden om geen native gebruiken'
	  		\item 'Ik prefereer snelheid en integratie van native'
	  	\end{itemize}	
	  	
		Als de tester beter weet wat de voordelen zijn van een PWA, waren er opvallend meer mensen die de PWA versie zouden verkiezen over de native versie. Hun grootste motivatie was de grootte van de applicatie. 
		Er waren X\% van de gebruikter die wel een PWA zouden verkiezen als ze weten wat de voordelen zijn voor hen.
		
		%todo: âœ…resultaat van user testing - zou de gebruiker notificaties toestaan
		Pus notificaties zijn een sterk middel om user engagement te verhogen. \autocite{Gaunt2020} Als een PWA hier gebruik wil van maken moet de gebruiker hier expliciet toestemming voor geven. 
		
		In de tweede proof-of-concept werd deze functie geÃ¯mplementeerd. De gebruiker kan deze zelf aanzetten, hij zal dus niet lastig gevallen worden met popup's die om toestemming vragen. Voor dat de gebruiker de notificaties aanzet, weet hij voor welke doelen dit gebruikt zal worden .Dit is volgens Matt Gaunt de beste user experience en zal dan ook resulteren in een hoog aantal mensen die notificaties toestaan. \autocite{Gaunt2019c}
		
		%todo:ðŸ“ˆ
		Er werd aan de gebruikers gevraagd als ze voor deze applicatie de notificaties zouden aan zetten. Een opvallen hoog percentage (X\%) zou toestemming geven aan een PWA om push notificaties te versturen.
				
		
		
	\subsection{A2HS}
		%todo: âœ… wanneer zou een user een applicatie installeren
		%todo:ðŸ“ˆ
		Bij het user testen werden de twee proof-of-concepts getoond aan de gebruiker. Bij de eerste proof-of-concept wordt er een standaard A2HS ervaring aangeboden. Op sommige browsers (Chrome, Edge, Firefox) zal de gebruiker een boodschap krijgen als hij de website voor het eerst bezoekt dat deze geÃ¯nstalleerd kan worden. Op andere browsers (Safari) zal dit helemaal niet aangeven worden.
		
		Bij de tweede proof-of-concept stond er een knop op de website waar de gebruiker altijd op kon klikken om de applicatie toe te voegen aan het startscherm. 
		
		Het was opvallend dat de gebruikers de tweede applicatie sneller zouden installeren dan de eerste. De testers gaven volgende feedback
		\begin{itemize}
	  		\item -'Voelt niet veilig'
			\item 'ik weet nog niet wat deze app zal doen'
			\item 'ik klik alle popups direct weg zonder te lezen wat er staat'
	  	\end{itemize}	

		Onderzoek \autocite{LePage2020b} toont aan dat de gebruiker meer en langere sessies heeft als de PWA te vinden is op het startscherm. Het is dus belangrijk om een goede A2HS experience te ontwikkelen.
		
		
		De A2HS ervaring op een IOS toestel is minder eenvoudig dan die op andere toestellen. De gebruiker moet manueel in de instelling van de website gaan om de app toe te voegen aan het startscherm. Dit is een omslachtig proces dat niet veel gebruikers kennen.
		
		%todo:ðŸ“ˆ
		Dit was ook terug te zien in de user testen. Tester op IOS voegen bijna nooit een PWA toe aan hun startscherm, terwijl mensen op Android dit wel zouden overwegen.
		
		
	
	\subsection{Native feeling}
		%todo:âœ…  Vond je de ervaring in de demo's gelijkaardig als die in een mobiele applicatie?
		
		Er werd onderzoek gedaan naar de user experience van een PWA die werd toegevoegd aan het startscherm. Deze applicaties hebben geen browserelementen en zien er dus meer uit als een native applicatie.
		
		
		%todo:ðŸ“ˆ
		De testers kregen de vraag "Vond je de ervaring in de demo's gelijkaardig als die in een mobiele applicatie?" Hier antwoordde X\% dat ze de ervaring van de PWA's gelijkaardig vonden aan die van een native applicatie.
		
		Ook hier valt op dat de tester die vonden dat de ervaring niet gelijkaardig was aan die van een native applicatie allemaal gebruikt maakten van een toestel met IOS als besturingssysteem.
		

		
	
	
	
	
			
		